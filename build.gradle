allprojects {
	version = '2.1.2'
	group = 'org.corewall'
}

defaultTasks 'clean', 'package'

task clean  {
	doLast {
		ant.delete(dir: file('dist'), failonerror: false)
		ant.delete(dir: file('bin'), failonerror: false)
	}
}

def javaRuntimeFile = null // replace with your Java 11 runtime

/**
 * Packaging tasks.	 It may be good to just extend the gradle dist task instead of having a custom task.
 */
task 'package-check'(dependsOn: [':app:build'])  {
	doLast {
		def required = file("scenegraph/dist/scenegraph-${version}.jar")
		if (!required.exists()) {
			logger.error("!! Missing required scenegraph library or version mismatch.  Expected: scenegraph/dist/scenegraph-${version}.jar")
			logger.error("!! The library must be generated (or re-generated for this version), see scenegraph/README.md for instructions.")
			throw new Error("Missing required scenegraph library or version mismatch.  Expected: scenegraph/dist/scenegraph-${version}.jar")
		}
		def javaRuntimeDir = file("packages/java_runtime")
		if (!javaRuntimeDir.exists()) {
			throw new Error("Error: Missing packages/java_runtime directory")
		}
		if (javaRuntimeFile == null) {
			throw new Error("Error: javaRuntimeFile var is null.\nTo resolve, update javaRuntimeFile var with your Java 11 runtime in build.gradle.")
		}
		if (javaRuntimeDir.listFiles().find { it.name.equals(javaRuntimeFile) } == null) {
			throw new Error("Error: Missing Java runtime '${javaRuntimeFile}' in packages/java_runtime")
		}
	}
}

task 'create-working-dir' {
	def wrk_dir = file('working_dir')
	if (!wrk_dir.exists()) {
		mkdir(wrk_dir)
	}
	copy {
		into wrk_dir
		from 'packages/base'
	}
}

// 'package' is a misnomer, this task just builds components and creates
// working_dir for command-line launch of Corelyzer.
task packageLinux(dependsOn: ['package-check', 'create-working-dir']) { }


// Package things up as a macOS/OSX .app bundle
task packageMac(dependsOn: 'package-check')  {
	doLast {
		def app = file('dist/mac/Corelyzer.app')
		if (app.exists()) {
			println "Found dist/mac/Corelyzer.app package, copying in latest app/dist, app/deps/mac, scenegraph/dist..."
			// copy the jars and native libraries
			copy {
				into 'dist/mac/Corelyzer.app/Contents/Resources/Java'
				from 'app/dist'
				from 'app/deps/mac'
				from file('scenegraph/dist').listFiles().findAll { it.name.endsWith('.jar') || it.name.endsWith('.jnilib') }
			}
		} else {
			println "No dist/mac/Corelyzer.app found, building from scratch..."
			mkdir(app)

			// copy the skeleton
			copy {
				into app
				from 'packages/mac'
			}

			// copy the base resources and help files
			copy {
				into 'dist/mac/Corelyzer.app/Contents/Resources'
				from 'packages/base/resources'
			}
			copy {
				into 'dist/mac/Corelyzer.app/Contents/help'
				from 'packages/base/help'
			}
			copy {
				into 'dist/mac/Corelyzer.app/Contents/plugins'
				from 'packages/base/plugins'
			}

			// copy the jars and native libraries
			copy {
				into 'dist/mac/Corelyzer.app/Contents/Resources/Java'
				from 'app/dist'
				from 'app/deps/mac'
				from file('scenegraph/dist').listFiles().findAll { it.name.endsWith('.jar') || it.name.endsWith('.jnilib') }
			}

			// copy Java runtime into bundle
			copy {
				from 'packages/java_runtime'
				into 'dist/mac/Corelyzer.app/Contents/Frameworks'
				include "${javaRuntimeFile}/**"
			}

			// update our Info.plist
			def classpath = file('dist/mac/Corelyzer.app/Contents/Resources/Java').listFiles().findAll { it.name.endsWith('.jar') }.collect { file ->
				'\t\t\t<string>\\$JAVAROOT/' + file.name + '</string>'
			}
			def plist = file('dist/mac/Corelyzer.app/Contents/Info.plist')
			def text = plist.text.toString()
			text = text.replaceAll(':version', version) // add our version
			text = text.replaceAll(':classpath', classpath.join('\n'))
			text = text.replaceAll(':java_runtime', javaRuntimeFile)
			plist.write(text)

			// make our app executable
			ant.chmod(file:"dist/mac/Corelyzer.app/Contents/MacOS/Corelyzer", perm:"ugo+rx")

			// codesign the app so Mac users are only pestered by the "Do you want Corelyzer
			// to allow incoming network connections" dialog once...otherwise it appears
			// at every launch.
			exec {
				println "Code signing app package"
				workingDir 'dist/mac'
				commandLine 'codesign', '--force', '--deep', '--sign', '-', 'Corelyzer.app'
				standardOutput = new ByteArrayOutputStream()
				println standardOutput.toString()
			}

			// tar and zip up app bundle
			def tarfile = "Corelyzer-${version}.tar.gz"
			println "Creating tarball ${tarfile}"
			ant.exec(executable: 'tar', dir: 'dist/mac') {
				arg(value: 'czvf')
				arg(value: tarfile)
				arg(value: 'Corelyzer.app')
			}
		}
	}
}

// Windows packaging
def winDist = file("dist/win/Corelyzer")
def winLibs = file('dist/win/Corelyzer/lib')
task packageWin(dependsOn: ['package-check', 'create-win-dist']) {
	doLast {
		// copy the jars to Corelyzer/lib
		copy {
			into winLibs
			from 'app/dist'
			from file('app/deps/win').listFiles().findAll { it.name.endsWith('.jar') }
			from file('scenegraph/dist').listFiles().findAll { it.name.endsWith('.jar') }
		}

		// copy dlls to Corelyzer since I couldn't find a way to make Windows find them in lib
		copy {
			into winDist
			from file('app/deps/win').listFiles().findAll { it.name.endsWith('.dll') }
			from file('scenegraph/dist').listFiles().findAll { it.name.endsWith('.dll') }
		}

		// copy help and resources
		copy {
			into 'dist/win/Corelyzer/help'
			from file('packages/base/help')
		}
		copy {
			into 'dist/win/Corelyzer/resources'
			from file('packages/base/resources')
		}

		// copy plugins
		copy {
			into 'dist/win/Corelyzer/plugins'
			from file('plugins').listFiles().findAll { it.name.endsWith('.jar') }
		}

		// create our zip file
		ant.zip(basedir: file("dist/win"), destfile: file("dist/win/Corelyzer-${version}.zip"), includes: "Corelyzer/**")

		// TODO create installer
	}
}

task 'create-win-dist' {
	doLast {
		if (!winDist.exists()) {
			mkdir(winDist)
			mkdir(winLibs)

			// copy the skeleton
			copy {
				into winDist
				from 'packages/win'
			}
		}
	}
}

task 'package'(dependsOn: ['packageMac', 'packageWin']) {
	doLast {}
}
