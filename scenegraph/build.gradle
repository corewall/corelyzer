apply plugin: 'java'
apply plugin: 'eclipse'

sourceCompatibility = 1.8
targetCompatibility = 1.8

jar.doFirst {
	manifest {
		attributes("Implementation-Title": "Corelyzer Scenegraph Library",
                      "Implementation-Version": version)
	}
} 

clean.doLast {
	ant.delete(dir: file('bin'), failonerror: false)
}

task 'clean-dist' {
	doLast {
		ant.delete(dir: file('dist'), failonerror: false)
	}
}

task 'generate-jni-headers'(dependsOn: 'build') {
	doLast {
		// copy our jar into dist/
		copy {
			into file('dist')
			from configurations.default.allArtifacts.getFiles()
		}

		// create build/cpp
		def build = new File(project.buildDir, 'cpp')
		mkdir(build)

		// generate the JNI header
		ant.exec(executable: 'javah', dir: file('dist'), failonerror: true) {
			arg(value: '-classpath')
			arg(value: "scenegraph-${version}.jar")
			arg(value: '-d')
			arg(path: build)
			arg(value: 'corelyzer.graphics.SceneGraph')
		}
	}

	// To build and debug, VSCode seems to depend on contents of build/classes/java
	// being copied into scenegraph/bin, but doesn't always do so on its own, unclear why.
	// Copy manually here. 
	mkdir('bin')
	copy {
		into file('bin')
		from 'build/classes/java/'
	}
}

task 'build-jni-mac'(dependsOn: 'generate-jni-headers') {
	doLast {
		def build = new File(project.buildDir, 'cpp')
		def dist = file('dist')
		def src = file('src/main/cpp')
		def deps = file('deps/mac')
		def includes = [
			src.absolutePath,
			dist.absolutePath,
			build.absolutePath,
			'/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers',
			file('deps/mac/include').absolutePath,
			file('deps/mac/include/freetype2').absolutePath]

		// compile
		mkdir(build)
		src.eachFileMatch({ it.endsWith('.c') || it.endsWith('.cpp')} ) { file ->
			compileMac(file, 'x86_64', includes, build)
		}

		// link
		def libs = file('deps/mac/lib').listFiles().findAll { it.name.endsWith('.a') }
		def rfile = file('src/main/cpp/mac.r')
		linkMac('x86_64', libs, rfile, build)

		// lipo
		ant.exec(executable: 'lipo', dir: build, failonerror: true) {
			arg(value: '-create')
			arg(value: '-arch')
			arg(value: 'x86_64')
			arg(value: 'x86_64.jnilib')
			arg(value: '-output')
			arg(path: new File(dist, 'libscenegraph.jnilib'))
		}
	}
}

def linkMac(arch, libs, rfile, dir) {
	ant {
		echo("Linking ${arch}.jnilib")
		exec(executable: 'c++', dir: dir, failonerror: true) {
			arg(value: '-mmacosx-version-min=10.12')
			arg(value: '-g')
			arg(value: '-bundle')
			arg(value: '-isysroot')
			arg(value: '/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk')
			arg(value: '-O')
			arg(value: '-arch')
			arg(value: arch)
			arg(value: '-framework')
			arg(value: 'JavaVM')
			arg(value: '-framework')
			arg(value: 'OpenGL')
			arg(value: '-lstdc++')
			arg(value: '-lpthread')
			arg(value: '-o')
			arg(value: "${arch}.jnilib")
			dir.listFiles().findAll { it.name.endsWith(arch) }.each { arg(path: it) }
			libs.each { arg(path: it) }
		}
		exec(executable: 'Rez', dir: dir, failonerror: true) {
			arg(value: '-t')
			arg(value: 'APPL')
			arg(value: '-o')
			arg(value: "${arch}.jnilib")
			arg(path: rfile)
		}
	}
}

def compileMac(src, arch, includes, dir) {
	def out = src.name.substring(0, src.name.lastIndexOf('.') + 1) + "${arch}"
	ant {
		echo("Compiling ${src.name} for Mac ${arch}")
		exec(executable: 'c++', dir: dir, logError: true, failonerror: true) {
			arg(value: '-mmacosx-version-min=10.12')
			arg(value: '-c')
			arg(value: '-isysroot')
			arg(value: '/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk')
			arg(value: '-O')
			arg(value: '-arch')
			arg(value: arch)
			arg(value: '-fPIC')
			if (arch != 'ppc') {
				arg(value: '-DUSE_FASTDXT')
			}
			arg(value: '-FOpenGL')
			includes.each { arg(value: "-I${it}") }
			arg(value: '-o')
			arg(value: out)
			arg(path: src)
		}
	}
}

task 'build-jni-linux'(dependsOn: 'generate-jni-headers') {
	doLast {
		def build = new File(project.buildDir, 'cpp')
		def dist = file('dist')
		def src = file('src/main/cpp')
		def includes = [
			src.absolutePath,
			dist.absolutePath,
			build.absolutePath,
			file('/usr/lib/jvm/java-11-openjdk-amd64/include'),
			file('/usr/lib/jvm/java-11-openjdk-amd64/include/linux'),
			file('/usr/include/freetype2')]

		mkdir(build)

		def arch = "x86_64"
		ant.echo("Generating libscenegraph for Linux ${arch}...")
		ant.exec(executable: 'gcc', dir: dist, logError: true, failonerror: true) {
			arg(value: '-O')
			arg(value: '-fPIC')
			arg(value: '-shared')
			arg(value: '-DUSE_FASTDXT')
			includes.each { arg(value: "-I${it}") }
			src.eachFileMatch({ it.endsWith('.c') || it.endsWith('.cpp')} ) { file ->
				println "Compiling $file..."
				arg(value: file)
			}
			arg(value: '-L')
			arg(value: '/usr/lib/x86_64-linux-gnu')
			arg(value: '-lpng')
			arg(value: '-lGL')
			arg(value: '-lGLU')
			arg(value: '-lstdc++')
			arg(value: '-lfreetype')
			arg(value: '-ljpeg')
			arg(value: '-ltiff')
			arg(value: '-lsquish')
			arg(value: '-o')
			arg(value: 'libscenegraph.so')
		}
	}
}

// cross-compile Window with MINGW...has unresolved texture
// generation issue at runtime, build with provided MSVC
// project instead.
task 'build-jni-win'(dependsOn: 'generate-jni-headers') {
	doLast {
		def build = new File(project.buildDir, 'cpp')
		def dist = file('dist')
		def src = file('src/main/cpp')
		def deps = file('deps/win32')
		def includes = [
			src.absolutePath,
			dist.absolutePath,
			build.absolutePath,
			deps.absolutePath,
			file('deps/win32/bootstrap/usr/i686-pc-mingw32/include/freetype2').absolutePath]

		// expand our cross-compile tarball
		def bootstrap = file('deps/win32/bootstrap')
		if (!bootstrap.exists()) {
			ant {
				echo("Expanding cross-compile environment")
				exec(executable: 'tar', dir: deps) {
					arg(value: 'xzvf')
					arg(value: 'bootstrap.tar.gz')
				}
			}
		}

		// 4/2/2012 brg: Don't bother compiling, cross-compiled Win32 build has
		// texture generation problems that I have yet to sort out.
		// Use working MSVC-built scenegraph.dll in deps.

		// compile
		//mkdir(build)
		//def path = file('deps/win32/bootstrap/usr/bin/').absolutePath
		//src.eachFileMatch({ it.endsWith('.c') || it.endsWith('.cpp')} ) { file ->
		//	compileWin(file, includes, build, path)
		//}

		// link
		//linkWin(deps.listFiles().findAll { it.name.endsWith('.lib')}, build, path)

		copy {
			into dist
			from new File(deps, 'scenegraph.dll') // MSVC build
			from new File(deps, 'OpenJPEG.dll')
			from new File(deps, 'pthreadVC2.dll')
		}
	}
}

def compileWin(src, includes, dir, path) {
	def out = src.name.substring(0, src.name.lastIndexOf('.') + 1) + "win32"
	ant {
		echo("Compiling ${src.name} for Win32")
		exec(executable: path + '/i686-pc-mingw32-c++', dir: dir, failonerror: true) {
			arg(value: '-c')
			arg(value: '-DUSE_FASTDXT')
			arg(value: '-msse2')
			arg(value: '-O')
			includes.each { arg(value: "-I${it}") }
			arg(value: '-o')
			arg(value: out)
			arg(path: src)
		}
	}
}

def linkWin(libs, dir, path) {
	ant {
		echo("Linking scenegraph.dll")
		exec(executable: path + '/i686-pc-mingw32-c++', dir: dir, failonerror: true) {
			arg(value: '-Wall')
			arg(value: '-shared')
			arg(value: '-o')
			arg(value: 'scenegraph.dll')
			dir.listFiles().findAll { it.name.endsWith('.win32') }.each { arg(path: it) }
			arg(value: '-lpng')
			arg(value: '-lstdc++')
			arg(value: '-lpthread')
			arg(value: '-ltiff')
			arg(value: '-ljpeg')
			arg(value: '-lz')
			arg(value: '-lopengl32')
			arg(value: '-lglu32')
			arg(value: '-lfreetype')
			arg(value: '-lws2_32')
			libs.each { arg(path: it) }
			arg(value: '-mwindows')
		}
	}
}
